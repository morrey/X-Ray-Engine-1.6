/*******************************************************************************
 * NVIDIA Corporation 
 * Software License Agreement - OpenAutomate SDK 
 * 
 * IMPORTANT - READ BEFORE COPYING, INSTALLING OR USING
 * Do not use or load the OpenAutomate SDK and any associated materials
 * provided by NVIDIA on NVIDIA’s website (collectively, the "Software")
 * until You have carefully read the following terms and conditions. By
 * loading or using the Software, You agree to fully comply with the terms
 * and conditions of this Software License Agreement ("Agreement") by and
 * between NVIDIA Corporation, a Delaware corporation with its principal
 * place of business at 2701 San Tomas Expressway, Santa Clara, California
 * 95050 U.S.A. ("NVIDIA"), and You. If You do not wish to so agree, do not
 * install or use the Software. 
 * 
 * For the purposes of this Agreement: 
 * 
 * "Licensee," "You" and/or "Your" shall mean, collectively and
 * individually, Original Equipment Manufacturers, Independent Hardware
 * Vendors, Independent Software Vendors, and End-Users of the Software
 * pursuant to the terms and conditions of this Agreement.   
 * 
 * "Derivative Works" shall mean derivatives of the Software created by You
 * or a third party on Your behalf, which term shall include:  (a) for
 * copyrightable or copyrighted material, any translation, abridgement,
 * revision or other form in which an existing work may be recast,
 * transformed or adapted; (b) for work protected by topography or mask
 * right, any translation, abridgement, revision or other form in which an
 * existing work may be recast, transformed or adapted; (c) for patentable
 * or patented material, any Improvement; and (d) for material protected by
 * trade secret, any new material derived from or employing such existing
 * trade secret.
 * 
 * "Excluded License" is any license that requires as a condition of use,
 * modification and/or distribution of software subject to the Excluded
 * License, that such software or other software distributed and/or
 * combined with such software be (i) disclosed or distributed in source
 * code form, (ii) licensed for the purpose of making derivative works, or
 * (iii) redistributable at no charge.
 * 
 * SECTION 1 - GRANT OF LICENSE.
 * NVIDIA agrees to provide the Software and any associated materials
 * pursuant to the terms and conditions of this Agreement.  Subject to the
 * terms of this Agreement, NVIDIA grants to You a nonexclusive,
 * transferable, worldwide, revocable, limited, royalty-free, fully paid-up
 * license under NVIDIA’s copyrights to 
 * 
 * (a) install, deploy, use, have used execute, reproduce, display,
 * perform, run, modify the source code of the Software, or to prepare and
 * have prepared Derivative Works thereof the Software for Your own
 * internal development, testing and maintenance purposes to incorporate
 * the Software or Derivative Works thereof, in part or whole, into Your
 * software applications; 
 * 
 * (b)	 to transfer, distribute and sublicense the Software (in its
 * unmodified form as delivered to You by NVIDIA pursuant to this
 * Agreement) in any medium or technology for Your sublicensees to
 * incorporate the Software or Derivative Works thereof, in part or whole,
 * into their respective software applications; and
 * 
 * (c) to transfer, distribute and sublicense Derivative Works (in object
 * code only) of the Software (i)_as incorporated in Your application
 * software in any medium or technology; and (ii) certified as OpenAutomate
 * Compatible Software.
 * 
 * You may exercise your license rights pursuant to Subsection 1(b) and (c)
 * above pursuant to the terms and conditions of any form of end-user
 * software license agreement of Your choice, including but not limited to
 * an Excluded License.
 * 
 * In the event NVIDIA certifies Your application software, incorporating
 * the Derivative Works (in object code only) of the Software, as
 * OpenAutomate compatible ("OpenAutomate Compatible Software"), NVIDIA
 * grants You a nonexclusive, worldwide, revocable, paid-up license to use
 * the name and trademark to "OpenAutomate Compatible" solely for the
 * purposes of identifying and/or marketing Your application software as
 * OpenAutomate Compatible Software; provided that Licensee fully complies
 * with the following:	
 * 
 * (x) Licensee agrees that it is strictly prohibited from using the name
 * and trademark of "OpenAutomate Compatible" if Your application software
 * is not OpenAutomate Compatible Software;
 * 
 * (y) if NVIDIA objects to Your improper use of the "OpenAutomate
 * Compatible" name and trademark, You will take all reasonable steps
 * necessary to resolve NVIDIA’s objections. NVIDIA may reasonably monitor
 * the quality of Your application software bearing the "OpenAutomate
 * Compatible" name or trademark pursuant to this Agreement; and
 * 
 * (z) any goodwill attached to NVIDIA’s trademarks, service marks, or
 * trade names belong to NVIDIA and this Agreement does not grant You any
 * right to use them.
 * 
 * If You are not the final manufacturer or vendor of a computer system or
 * software program incorporating the Software, or if Your Contractors (as
 * defined below), affiliates or subsidiaries need to exercise any, some or
 * all of the license grant described above herein to the Software on Your
 * behalf, then You may transfer a copy of the Software, (and related
 * end-user documentation) to such recipient for use in accordance with the
 * terms of this Agreement, provided such recipient agrees to be fully
 * bound by the terms hereof. Except as expressly permitted in this
 * Agreement, Unless otherwise authorized in the Agreement, You shall not
 * otherwise assign, sublicense, lease, or in any other way transfer or
 * disclose Software to any third party. Unless otherwise authorized in the
 * Agreement, You shall not reverse- compile, disassemble,
 * reverse-engineer, or in any manner attempt to derive the source code of
 * the Software from the object code portions of the Software. 
 * 
 * Except as expressly stated in this Agreement, no license or right is
 * granted to You directly or by implication, inducement, estoppel or
 * otherwise. NVIDIA shall have the right to inspect or have an independent
 * auditor inspect Your relevant records to verify Your compliance with the
 * terms and conditions of this Agreement. 
 * 
 * SECTION 2 - CONFIDENTIALITY.
 * If applicable, any exchange of Confidential Information (as defined in
 * the NDA) shall be made pursuant to the terms and conditions of a
 * separately signed Non-Disclosure Agreement ("NDA") by and between NVIDIA
 * and You. For the sake of clarity, You agree that the Software is
 * Confidential Information of NVIDIA.
 * 
 * If You wish to have a third party consultant or subcontractor
 * ("Contractor") perform work on Your behalf which involves access to or
 * use of Software, You shall obtain a written confidentiality agreement
 * from the Contractor which contains terms and obligations with respect to
 * access to or use of Software no less restrictive than those set forth in
 * this Agreement and excluding any distribution or sublicense rights, and
 * use for any other purpose than permitted in this Agreement. Otherwise,
 * You shall not disclose the terms or existence of this Agreement or use
 * NVIDIA's name in any publications, advertisements, or other
 * announcements without NVIDIA's prior written consent.  Unless otherwise
 * provided in this Agreement, You do not have any rights to use any NVIDIA
 * trademarks or logos.
 * 
 * SECTION 3 - OWNERSHIP OF SOFTWARE AND INTELLECTUAL PROPERTY RIGHTS.
 * All rights, title and interest to all copies of the Software remain with
 * NVIDIA, subsidiaries, licensors, or its suppliers. The Software is
 * copyrighted and protected by the laws of the United States and other
 * countries, and international treaty provisions. You may not remove any
 * copyright notices from the Software. NVIDIA may make changes to the
 * Software, or to items referenced therein, at any time and without
 * notice, but is not obligated to support or update the Software. Except
 * as otherwise expressly provided, NVIDIA grants no express or implied
 * right under any NVIDIA patents, copyrights, trademarks, or other
 * intellectual property rights. 
 * 
 * All rights, title and interest in the Derivative Works of the Software
 * remain with You subject to the underlying license from NVIDIA to the
 * Software.  In Your sole discretion, You may grant NVIDIA, upon NVIDIA’s
 * request for such a license described herein, an irrevocable, perpetual,
 * nonexclusive, worldwide, royalty-free paid-up license to make, have
 * made, use, have used, sell, license, distribute, sublicense or otherwise
 * transfer Derivative Works created by You that add functionality or
 * improvement to the Software.  
 * 
 * You has no obligation to give NVIDIA any suggestions, comments or other
 * feedback ("Feedback") relating to the Software.  However, NVIDIA may use
 * and include any Feedback that You voluntarily provide to improve the
 * Software or other related NVIDIA technologies.  Accordingly, if You
 * provide Feedback, You agree NVIDIA and its licensees may freely use,
 * reproduce, license, distribute, and otherwise commercialize the Feedback
 * in the Software or other related technologies without the payment of any
 * royalties or fees.  
 * 
 * You may transfer the Software only if the recipient agrees to be fully
 * bound by these terms and conditions of this Agreement. 
 * 
 * SECTION 4 - NO WARRANTIES. 
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY EXPRESS OR IMPLIED WARRANTY
 * OF ANY KIND, INCLUDING WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT,
 * OR FITNESS FOR A PARTICULAR PURPOSE. NVIDIA does not warrant or assume
 * responsibility for the accuracy or completeness of any information,
 * text, graphics, links or other items contained within the Software.
 * NVIDIA does not represent that errors or other defects will be
 * identified or corrected.
 * 
 * SECTION 5 - LIMITATION OF LIABILITY.
 * EXCEPT WITH RESPECT TO THE MISUSE OF THE OTHER PARTY’S INTELLECTUAL
 * PROPERTY OR DISCLOSURE OF THE OTHER PARTY’S CONFIDENTIAL INFORMATION IN
 * BREACH OF THIS AGREEMENT, IN NO EVENT SHALL NVIDIA, SUBSIDIARIES,
 * LICENSORS, OR ITS SUPPLIERS BE LIABLE FOR ANY DAMAGES WHATSOEVER
 * (INCLUDING, WITHOUT LIMITATION,  INDIRECT, LOST PROFITS, CONSEQUENTIAL,
 * BUSINESS INTERRUPTION OR LOST INFORMATION) ARISING OUT OF THE USE OF OR
 * INABILITY TO USE THE SOFTWARE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES. SOME JURISDICTIONS PROHIBIT EXCLUSION OR
 * LIMITATION OF LIABILITY FOR IMPLIED WARRANTIES OR CONSEQUENTIAL OR
 * INCIDENTAL DAMAGES, SO THE ABOVE LIMITATION MAY NOT APPLY TO YOU. YOU
 * MAY ALSO HAVE OTHER LEGAL RIGHTS THAT VARY FROM JURISDICTION TO
 * JURISDICTION.  NOTWITHSTANDING THE FOREGOING, NVIDIA’S AGGREGATE
 * LIABILITY ARISING OUT OF THIS AGREEMENT SHALL NOT EXCEED ONE HUNDRED
 * UNITED STATES DOLLARS (USD$100).
 * 
 * SECTION 6 - TERM.
 * This Agreement and the licenses granted hereunder shall be effective as
 * of the date You download the applicable Software ("Effective Date") and
 * continue for a period of one (1) year ("Initial Term") respectively,
 * unless terminated earlier in accordance with the "Termination" provision
 * of this Agreement.  Unless either party notifies the other party of its
 * intent to terminate this Agreement at least three (3) months prior to
 * the end of the Initial Term or the applicable renewal period, this
 * Agreement will be automatically renewed for one (1) year renewal periods
 * thereafter, unless terminated in accordance with the "Termination"
 * provision of this Agreement.  
 * 
 * SECTION 7 - TERMINATION.
 * NVIDIA may terminate this Agreement at any time if You violate its
 * terms. Upon termination, You will immediately destroy the Software or
 * return all copies of the Software to NVIDIA, and certify to NVIDIA in
 * writing that such actions have been completed.  Upon termination or
 * expiration of this Agreement the license grants to Licensee shall
 * terminate, except that sublicenses rightfully granted by Licensee under
 * this Agreement in connection with Section 1(b) and (c) of this Agreement
 * provided by Licensee prior to the termination or expiration of this
 * Agreement shall survive in accordance with their respective form of
 * license terms and conditions.
 * 
 * SECTION 8 - MISCELLANEOUS.
 * 
 * SECTION 8.1 - SURVIVAL.
 * Those provisions in this Agreement, which by their nature need to
 * survive the termination or expiration of this Agreement, shall survive
 * termination or expiration of the Agreement, including but not limited to
 * Sections 2, 3, 4, 5, 7, and 8.
 * 
 * SECTION 8.2 - APPLICABLE LAWS.
 * Claims arising under this Agreement shall be governed by the laws of
 * Delaware, excluding its principles of conflict of laws and the United
 * Nations Convention on Contracts for the Sale of Goods. The state and/or
 * federal courts residing in Santa Clara County, California shall have
 * exclusive jurisdiction over any dispute or claim arising out of this
 * Agreement. You may not export the Software in violation of applicable
 * export laws and regulations. 
 * 
 * SECTION 8.3 - AMENDMENT.
 * The Agreement shall not be modified except by a written agreement that
 * names this Agreement and any provision to be modified, is dated
 * subsequent to the Effective Date, and is signed by duly authorized
 * representatives of both parties.
 * 
 * SECTION 8.4 - NO WAIVER.
 * No failure or delay on the part of either party in the exercise of any
 * right, power or remedy under this Agreement or under law, or to insist
 * upon or enforce performance by the other party of any of the provisions
 * of this Agreement or under law, shall operate as a waiver thereof, nor
 * shall any single or partial exercise of any right, power or remedy
 * preclude other or further exercise thereof, or the exercise of any other
 * right, power or remedy; rather the provision, right, or remedy shall be
 * and remain in full force and effect.
 * 
 * SECTION 8.5 - NO ASSIGNMENT. 
 * This Agreement and Licensee’s rights and obligations herein, may not be
 * assigned, subcontracted, delegated, or otherwise transferred by Licensee
 * without NVIDIA’s prior written consent, and any attempted assignment,
 * subcontract, delegation, or transfer in violation of the foregoing will
 * be null and void.  The terms of this Agreement shall be binding upon
 * Licensee’s assignees.
 * 
 * SECTION 8.6 - GOVERNMENT RESTRICTED RIGHTS. 
 * The parties acknowledge that the Software is subject to U.S. export
 * control laws and regulations.   The parties agree to comply with all
 * applicable international and national laws that apply to the Software,
 * including the U.S. Export Administration Regulations, as well as
 * end-user, end-use and destination restrictions issued by U.S. and other
 * governments.
 * 
 * The Software has been developed entirely at private expense and is
 * commercial computer software provided with RESTRICTED RIGHTS. Use,
 * duplication or disclosure of the Software by the U.S. Government or a
 * U.S. Government subcontractor is subject to the restrictions set forth
 * in the Agreement under which the Software was obtained pursuant to DFARS
 * 227.7202-3(a) or as set forth in subparagraphs (c)(1) and (2) of the
 * Commercial Computer Software - Restricted Rights clause at FAR
 * 52.227-19, as applicable. Contractor/manufacturer is NVIDIA, 2701 San
 * Tomas Expressway, Santa Clara, CA 95050. Use of the Software by the
 * Government constitutes acknowledgment of NVIDIA's proprietary rights
 * therein. 
 * 
 * SECTION 8.7 - INDEPENDENT CONTRACTORS.
 * Licensee’s relationship to NVIDIA is that of an independent contractor,
 * and neither party is an agent or partner of the other.  Licensee will
 * not have, and will not represent to any third party that it has, any
 * authority to act on behalf of NVIDIA.
 * 
 * SECTION 8.8 - SEVERABILITY.
 * If for any reason a court of competent jurisdiction finds any provision
 * of this Agreement, or portion thereof, to be unenforceable, that
 * provision of the Agreement will be enforced to the maximum extent
 * permissible so as to affect the intent of the parties, and the remainder
 * of this Agreement will continue in full force and effect. This Agreement
 * has been negotiated by the parties and their respective counsel and will
 * be interpreted fairly in accordance with its terms and without any
 * strict construction in favor of or against either party.
 * 
 * SECTION 8.9 - ENTIRE AGREEMENT.  
 * This Agreement and NDA constitute the entire agreement between the
 * parties with respect to the subject matter contemplated herein, and
 * merges all prior and contemporaneous communications.
 * 
 ******************************************************************************/



#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <oac/Context.h>
#include <oac/TestBase.h>
#include <oac/OAUtils.h>
#include <oac/Log.h>

using namespace std;

//******************************************************************************
//*** oacContext static varables
//******************************************************************************

oacContext *oacContext::pCurrent = NULL;
oaRPCFunctionTable oacContext::pFuncTable;
oaInt oacContext::pCallCount = 0;

//******************************************************************************
//*** oacContext::OptionValue methods
//******************************************************************************

oacContext::OptionValue::OptionValue()
{
  Name = NULL;
  Type = OA_TYPE_INVALID;
  memset(&Value, 0, sizeof(Value));
}

oacContext::OptionValue::OptionValue(const OptionValue &val)
{
  Name = NULL;
  Type = OA_TYPE_INVALID;
  memset(&Value, 0, sizeof(Value));
  Set(val.Name, val.Type, &val.Value);
}

void oacContext::OptionValue::Set(const oaChar *name,
                                  oaOptionDataType value_type,
                                  const oaValue *value)
{
  if(Name != NULL)
    free(Name);

  switch(Type)
  {
    case OA_TYPE_STRING:
      if(Value.String)
        free(Value.String);
      break;

    case OA_TYPE_ENUM:
      if(Value.Enum)
        free(Value.Enum);
      break;
  }

  Name = (name == NULL) ? NULL : strdup(name);
  Type = value_type;

  if(value != NULL)
  {
    switch(Type)
    {
      case OA_TYPE_STRING:
        if(value->String != NULL)
          Value.String = strdup(value->String);
        break;

      case OA_TYPE_ENUM:
        if(value->Enum != NULL)
          Value.Enum = strdup(value->Enum);
        break;

      default:
        Value = *value;
    }
  }
  else
    memset(&Value, 0, sizeof(Value));
}
             
oacContext::OptionValue::~OptionValue()
{
  Set(NULL, OA_TYPE_INVALID, NULL);
}


//******************************************************************************
//*** oacContext::ClientApp methods
//******************************************************************************

oacContext::ClientApp::~ClientApp()
{
}

//******************************************************************************
//*** oacContext methods
//******************************************************************************

oacContext::oacContext(oaRPCServer *server,
                       ClientApp *client_app)
{
  assert(server != NULL);

  pServer = server;
  pClientApp = client_app;

  pRandSeed = 69;
  pTestLoops = 2;
  pBeginModulatingLoop = 2;

  pHaveBenchmarks = false;
  pHaveAllOptions = false;
  pHaveCurrentOptions = false;

  pState.push_back(STATE_INIT);

  memset(&pFuncTable, 0, sizeof(pFuncTable));
  pFuncTable.GetNextCommand = GetNextCommand;
  pFuncTable.GetNextOption = GetNextOption;
  pFuncTable.AddOption = AddOption;
  pFuncTable.AddOptionValue = AddOptionValue;
  pFuncTable.AddBenchmark = AddBenchmark;
  pFuncTable.SendSignal = SendSignal;
  pFuncTable.StartBenchmark = StartBenchmark;
  pFuncTable.EndBenchmark = EndBenchmark;
  pFuncTable.DisplayFrame = DisplayFrame;
  pFuncTable.AddResultValue = AddResultValue;
  pFuncTable.AddFrameValue = AddFrameValue;
  pFuncTable.UserData = NULL;
}

oacContext::~oacContext()
{
  vector<oacTestBase *>::iterator Iter = pTests.begin();
  for(; Iter != pTests.end(); Iter++)
    delete *Iter;

  ClearBenchmarks();
  ClearAllOptions();
  ClearCurrentOptions();
  ClearTestGroups();
}

bool oacContext::Run(void)
{
  assert(pClientApp != NULL);

  pCurrent = this;

  bool Ret = pClientApp->Run();

  return(Ret);
}

bool oacContext::IsAModule(char* module_name) 
{
  pCurrentTest = pTests.begin();
  for(int i=1; pCurrentTest != pTests.end();pCurrentTest++, i++)
  {
    oacTestBase *Test = *pCurrentTest;
    oacTestBase::Info *Info = Test->GetInfo();

    if(!strcmp(module_name, Info->Name))
      return true;

    delete Info;
  }
  return false;
}

bool oacContext::IsTestActive(oacTestBase * test)
{ 
  if(pActiveTests.size() > 0) 
  {
    std::vector<char*>::iterator TestIter = pActiveTests.begin();
    for(; TestIter != pActiveTests.end(); TestIter++)
    {
      oacTestBase::Info *Info = test->GetInfo();
      if(!strcmp((char*)*TestIter,Info->Name ))
        return true;
    }
  }
  else
  {
    return true;
  }

  return false;
}

bool oacContext::ParseActiveTestList(char *test_list)
{
  char seps[]   = ";";
  char *token;

  if(test_list == NULL)
    return true;

  token = strtok(test_list, seps);

  while( token != NULL )
  {
    if( IsAModule(token) )
      pActiveTests.push_back(token);
    else
    {
      OAC_ERROR("Test: "<<token<<" is not a defined test module.");
      return false;
    }

    token = strtok( NULL, seps );
  }

  return true;
}

void oacContext::AddTest(oacTestBase *test)
{
  assert(test != NULL);
  
  // All tests must be added before the tests are run
  assert(State() == STATE_INIT); 

  test->SetContext(this);

  pTests.push_back(test);
}

const oaRPCFunctionTable *oacContext::GetOAFuncTable(void)
{
  return(&pFuncTable);
}

void oacContext::IssueCommand(oaCommand *command)
{
  assert(command != NULL);

  PushState(STATE_ISSUING_COMMAND);
  pCurrentCommand = command->Type;

  switch(pCurrentCommand)
  {
    case OA_CMD_GET_BENCHMARKS:
      ClearBenchmarks();
      pHaveBenchmarks = true;
      break;

    case OA_CMD_GET_ALL_OPTIONS:
      ClearAllOptions();
      pHaveAllOptions = true;
      break;
      
    case OA_CMD_GET_CURRENT_OPTIONS:
      ClearCurrentOptions();
      pHaveCurrentOptions = true;
      break;
  }

  oaRPCServerErrorType Ret = oaRPCServerNestCommand(pServer, command);
  assert(Ret == OARPC_SERVER_ERROR_OK);

  PopState();
}
static oaBool PostExitFunc(void *data)
{
  assert(data != NULL);

  oacContext::ClientApp *ClientApp = (oacContext::ClientApp *)data;

  long ExitCode = ClientApp->WaitForExit();

  if(ExitCode != 0)
    OAC_ERROR("Client exited with non-zero exit code " << ExitCode << ".")

  if(!ClientApp->Run())
    OAC_ERROR("Restarting client application failed.")

  return(OA_TRUE);
}

void oacContext::IssueExitAndRestart(void)
{
  oaCommand Command;
  oaRPCServerErrorType Ret;

  oaInitCommand(&Command);
  Command.Type = OA_CMD_EXIT;

  Ret = oaRPCServerSendExitCommand(pServer, &PostExitFunc, pClientApp);
  if(OARPC_SERVER_ERROR_OK != Ret)
    OAC_ERROR("Could not restart client application.");
}

void oacContext::ClearBenchmarks(void)
{
  pBenchmarks.clear();
}

const vector<string> &oacContext::GetBenchmarks(bool force_cmd)
{
  if(force_cmd || !pHaveBenchmarks)
  {
    oaCommand Command;
    oaInitCommand(&Command);
    Command.Type = OA_CMD_GET_BENCHMARKS;
    IssueCommand(&Command);
  }

  return(pBenchmarks);
}

double oacContext::Rand(void)
{
  assert(sizeof(pRandSeed) == 4);
  pRandSeed = (1366 * pRandSeed + 150889) % 714025;
  return((double)pRandSeed  / 714025.0);
}

void oacContext::SRand(unsigned long seed)
{
  pRandSeed = seed;
}

void oacContext::Loop(int loop_count)
{
  pTestLoops = loop_count;
}

void oacContext::ModulateLoop(int loop_number)
{
  pBeginModulatingLoop = loop_number;
}

static void FreeOption(oaNamedOption &option)
{
  assert(option.Name != NULL);
  free((void *)option.Name);

  switch(option.DataType)
  {
    case OA_TYPE_STRING:
      free(option.Value.String);
      break;

    case OA_TYPE_ENUM:
      free(option.Value.Enum);
      break;
  }
  if(option.Dependency.ParentName)
    free((void *)option.Dependency.ParentName);
}

void oacContext::ClearAllOptions(void)
{
  vector<oaNamedOption>::iterator Iter = pAllOptions.begin();
  for(; Iter != pAllOptions.end(); Iter++)
    FreeOption(*Iter);

  map<string, OptionVec *>::iterator MapIter = pAllOptionsMap.begin();
  for(; MapIter != pAllOptionsMap.end(); MapIter++)
    delete MapIter->second;

  pAllOptions.clear();
  pAllOptionsMap.clear();
}

const vector<oaNamedOption> &oacContext::GetAllOptions(bool force_cmd)
{
  if(force_cmd || !pHaveAllOptions)
  {
    oaCommand Command;
    oaInitCommand(&Command);
    Command.Type = OA_CMD_GET_ALL_OPTIONS;
    IssueCommand(&Command);
  }

  return(pAllOptions);
}

const std::map<std::string, oacContext::OptionVec *> &
  oacContext::GetAllOptionsMap(bool force_cmd)
{
  GetAllOptions(force_cmd);  // ensure we have the map filled.
  return(pAllOptionsMap);
}

const oacContext::OptionVec *
  oacContext::GetOption(const oaChar *name, bool force_cmd)
{
  return(GetOption(std::string(name), force_cmd));  
}

const oacContext::OptionVec *
  oacContext::GetOption(const std::string &name, bool force_cmd)
{
  const std::map<std::string, OptionVec *> &Map =
    GetAllOptionsMap(force_cmd);

  std::map<string, OptionVec *>::const_iterator Found = Map.find(name);

  if(Found == Map.end())
    return(NULL);

  return(Found->second);
}

void oacContext::ClearCurrentOptions(void)
{
  vector<OptionValue *>::iterator Iter = pCurrentOptions.begin();
  for(; Iter != pCurrentOptions.end(); Iter++)
    delete *Iter;

  pCurrentOptions.clear();
  pCurrentOptionsMap.clear();
}

void oacContext::ClearTestGroups(void)
{
  vector<TestGroup*>::iterator Iter = pTestGroups.begin();
  for(; Iter != pTestGroups.end(); Iter++)
    delete(*Iter);
}

const vector<oacContext::OptionValue *> &
  oacContext::GetCurrentOptions(bool force_cmd)
{
  if(force_cmd || !pHaveCurrentOptions)
  {
    oaCommand Command;
    oaInitCommand(&Command);
    Command.Type = OA_CMD_GET_CURRENT_OPTIONS;
    IssueCommand(&Command);
  }

  return(pCurrentOptions);
}

const std::map<std::string, oacContext::OptionValue *> &
  oacContext::GetCurrentOptionsMap(bool force_cmd)
{
  GetCurrentOptions(force_cmd); // ensure we have the map filled.
  return(pCurrentOptionsMap);
}

const oacContext::OptionValue *
  oacContext::GetOptionValue(const oaChar *name, 
                             bool force_cmd)
{
  return(GetOptionValue(std::string(name), force_cmd));  
}

const oacContext::OptionValue *
  oacContext::GetOptionValue(const std::string &name,
                             bool force_cmd)
{
  const std::map<std::string, OptionValue *> &Map =
    GetCurrentOptionsMap(force_cmd);

  std::map<string, OptionValue *>::const_iterator Found = Map.find(name);

  if(Found == Map.end())
    return(NULL);

  return(Found->second);
}

void oacContext::RunTests(void)
{
  assert(State() == STATE_INIT);

  PushState(STATE_RUNNING_TEST);

  for(int Loop =0; Loop < pTestLoops; Loop++)
  {
    pCurrentTest = pTests.begin();
    for(int i=1; pCurrentTest != pTests.end();pCurrentTest++, i++)
    {
      oacTestBase *Test = *pCurrentTest;
      oacTestBase::Info *Info = Test->GetInfo();
      if(IsTestActive(Test))
      {
        OAC_START_TEST_GROUP(Info->Name);
        Test->Run();
        OAC_END_TEST_GROUP;
        if( Loop >= pBeginModulatingLoop - 1)
          IssueExitAndRestart();
      }
      delete Info;
    }
  }

  PopState();
  ChangeState(STATE_FINISHED);

  OAC_MSG("Final summary: " << oacLog::TestsSummary())
}

oacContext::StateType oacContext::State(void) const 
{ 
  return(pState.back()); 
}

void oacContext::PushState(StateType state) 
{ 
  pState.push_back(state); 
}

void oacContext::ChangeState(StateType state) 
{ 
  assert(pState.size() > 0);
  pState.back() = state; 
}

void oacContext::PopState(void) 
{ 
  assert(pState.size() > 1);
  pState.pop_back(); 
}

//******************************************************************************
//*** OA callback methods
//******************************************************************************

#define INC_CALL_COUNT(is_get_next_command) \
  pCallCount++; \
  if(!is_get_next_command) \
  { \
    OAC_TEST_MSG(pCallCount != 1, \
      "The first OA call made by the application must be oaGetNextCommand()."); \
  }

oaCommandType oacContext::GetNextCommand(void* context, oaCommand *command)
{
  INC_CALL_COUNT(true);

  assert(pCurrent != NULL);

  assert(command != NULL);
  assert(command->StructSize == sizeof(oaCommand));
  assert(pCurrent->State() == STATE_INIT);


  if(pCurrent)
    pCurrent->RunTests();

  if(command != NULL)
    command->Type = OA_CMD_EXIT;

  return(OA_CMD_EXIT);
}

#define TEST_CURRENT_CMD(cmd, func_name) \
  { \
    const char TmpMsg[] =  "The command " #cmd " must be issued before " \
      #func_name "() is called."; \
    OAC_TEST_MSG(pCurrent->State() == STATE_ISSUING_COMMAND, TmpMsg); \
    OAC_TEST_MSG(pCurrent->pCurrentCommand == cmd, TmpMsg); \
  }

oaNamedOption *oacContext::GetNextOption(void* context)
{
  INC_CALL_COUNT(false);

  TEST_CURRENT_CMD(OA_CMD_SET_OPTIONS, oaGetNextOption)

  if(pCurrent->State() == STATE_ISSUING_COMMAND)
    return((*pCurrent->pCurrentTest)->GetNextOption());

  return(NULL);
}

static void CopyOption(const oaNamedOption *src, oaNamedOption &dst)
{
  oaInitOption(&dst);
  memcpy(&dst, src, sizeof(oaNamedOption));
  dst.Name = strdup(src->Name);

  switch(src->DataType)
  {
    case OA_TYPE_STRING:
      dst.Value.String = strdup(src->Value.String);
      break;

    case OA_TYPE_ENUM:
      dst.Value.Enum = strdup(src->Value.Enum);
      break;
  }

  if(src->Dependency.ParentName)
    dst.Dependency.ParentName = strdup(src->Dependency.ParentName);
}

void oacContext::AddOption(void* context, const oaNamedOption *option)
{
  INC_CALL_COUNT(false);
  TEST_CURRENT_CMD(OA_CMD_GET_ALL_OPTIONS , oaAddOption)

  string Name(option->Name);

  oaNamedOption NewOption;
  CopyOption(option, NewOption);
  pCurrent->pAllOptions.push_back(NewOption);

  const OptionVec *FoundOption = pCurrent->GetOption(Name);
  if(FoundOption != NULL)
  {
    assert(FoundOption->size() > 0);

    oaOptionDataType FoundType = FoundOption->back().DataType;

    OAC_TEST_MSG(FoundType == OA_TYPE_ENUM,
     "Option named '" << Name << "' was added with oaAddOption() more than "
     "once.  This is only allowed for options of enum type.  The option "
     " already added is of type '" << oacOAUtils::TypeToStr(FoundType) << "'.");

    OAC_TEST_MSG(NewOption.DataType == OA_TYPE_ENUM,
     "Option named '" << Name << "' was added with oaAddOption() more than "
     "once.  This is only allowed for options of enum type.  The option "
     " being added is of type '" << oacOAUtils::TypeToStr(NewOption.DataType) <<
     "'.");
  }
  else
    pCurrent->pAllOptionsMap[Name] = new OptionVec;
    
  pCurrent->pAllOptionsMap[Name]->push_back(NewOption);
  

  if(pCurrent->State() == STATE_ISSUING_COMMAND)
    (*pCurrent->pCurrentTest)->AddOption(option);
}

void oacContext::AddOptionValue(void* context,
                                const oaChar *name,
                                oaOptionDataType value_type,
                                const oaValue *value)
{
  INC_CALL_COUNT(false);
  TEST_CURRENT_CMD(OA_CMD_GET_CURRENT_OPTIONS , oaAddOptionValue)

  string Name(name);

  OptionValue *NewOption = new OptionValue;
  NewOption->Set(name, value_type, value);

  pCurrent->pCurrentOptions.push_back(NewOption);

  map<string, OptionValue *>::const_iterator FoundOption;
  FoundOption = pCurrent->pCurrentOptionsMap.find(Name);
  OAC_TEST_MSG(FoundOption == pCurrent->pCurrentOptionsMap.end(),
   "Option named '" << Name << "' was added with oaAddOptionValue() more than "
   "once.");

  pCurrent->pCurrentOptionsMap[Name] = NewOption;

  if(pCurrent->State() == STATE_ISSUING_COMMAND)
    (*pCurrent->pCurrentTest)->AddOptionValue(name, value_type, value);
}

void oacContext::AddBenchmark(void* context, const oaChar *benchmark_name)
{
  INC_CALL_COUNT(false);
  TEST_CURRENT_CMD(OA_CMD_GET_BENCHMARKS , oaAddBenchmark)

  pCurrent->pBenchmarks.push_back(string(benchmark_name));

  if(pCurrent->State() == STATE_ISSUING_COMMAND)
    (*pCurrent->pCurrentTest)->AddBenchmark(benchmark_name);
}

oaBool oacContext::SendSignal(void* context, oaSignalType signal, void *param)
{
  INC_CALL_COUNT(false);

  if(pCurrent->State() == STATE_ISSUING_COMMAND)
    (*pCurrent->pCurrentTest)->SendSignal(signal, param);

  return(OA_FALSE);
}

void oacContext::StartBenchmark(void* context)
{
  INC_CALL_COUNT(false);
  TEST_CURRENT_CMD(OA_CMD_RUN_BENCHMARK , oaStartBenchmark)

  if(pCurrent->State() == STATE_ISSUING_COMMAND)
    (*pCurrent->pCurrentTest)->StartBenchmark();
}

void oacContext::DisplayFrame(void* context, oaFloat t)
{
  INC_CALL_COUNT(false);
  TEST_CURRENT_CMD(OA_CMD_RUN_BENCHMARK , oaDisplayFrame)

  if(pCurrent->State() == STATE_ISSUING_COMMAND)
    (*(pCurrent->pCurrentTest))->DisplayFrame(t);
}

void oacContext::EndBenchmark(void* context)
{
  INC_CALL_COUNT(false);
  TEST_CURRENT_CMD(OA_CMD_RUN_BENCHMARK , oaEndBenchmark)

  if(pCurrent->State() == STATE_ISSUING_COMMAND)
    (*pCurrent->pCurrentTest)->EndBenchmark();
}

void oacContext::AddResultValue(void* context,
                                const oaChar *name, 
                                oaOptionDataType value_type,
                                const oaValue *value)
{
  INC_CALL_COUNT(false);
  TEST_CURRENT_CMD(OA_CMD_RUN_BENCHMARK , oaAddResultValue)

  if(pCurrent->State() == STATE_ISSUING_COMMAND)
    (*pCurrent->pCurrentTest)->AddResultValue(name, value_type, value);
}

void oacContext::AddFrameValue(void* context,
                               const oaChar *name, 
                               oaOptionDataType value_type,
                               const oaValue *value)
{
  INC_CALL_COUNT(false);
  TEST_CURRENT_CMD(OA_CMD_RUN_BENCHMARK , oaAddFrameValue)

  if(pCurrent->State() == STATE_ISSUING_COMMAND)
    (*pCurrent->pCurrentTest)->AddFrameValue(name, value_type, value);
}


