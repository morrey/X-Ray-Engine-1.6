/*******************************************************************************
 * NVIDIA Corporation 
 * Software License Agreement - OpenAutomate SDK 
 * 
 * IMPORTANT - READ BEFORE COPYING, INSTALLING OR USING
 * Do not use or load the OpenAutomate SDK and any associated materials
 * provided by NVIDIA on NVIDIA’s website (collectively, the "Software")
 * until You have carefully read the following terms and conditions. By
 * loading or using the Software, You agree to fully comply with the terms
 * and conditions of this Software License Agreement ("Agreement") by and
 * between NVIDIA Corporation, a Delaware corporation with its principal
 * place of business at 2701 San Tomas Expressway, Santa Clara, California
 * 95050 U.S.A. ("NVIDIA"), and You. If You do not wish to so agree, do not
 * install or use the Software. 
 * 
 * For the purposes of this Agreement: 
 * 
 * "Licensee," "You" and/or "Your" shall mean, collectively and
 * individually, Original Equipment Manufacturers, Independent Hardware
 * Vendors, Independent Software Vendors, and End-Users of the Software
 * pursuant to the terms and conditions of this Agreement.   
 * 
 * "Derivative Works" shall mean derivatives of the Software created by You
 * or a third party on Your behalf, which term shall include:  (a) for
 * copyrightable or copyrighted material, any translation, abridgement,
 * revision or other form in which an existing work may be recast,
 * transformed or adapted; (b) for work protected by topography or mask
 * right, any translation, abridgement, revision or other form in which an
 * existing work may be recast, transformed or adapted; (c) for patentable
 * or patented material, any Improvement; and (d) for material protected by
 * trade secret, any new material derived from or employing such existing
 * trade secret.
 * 
 * "Excluded License" is any license that requires as a condition of use,
 * modification and/or distribution of software subject to the Excluded
 * License, that such software or other software distributed and/or
 * combined with such software be (i) disclosed or distributed in source
 * code form, (ii) licensed for the purpose of making derivative works, or
 * (iii) redistributable at no charge.
 * 
 * SECTION 1 - GRANT OF LICENSE.
 * NVIDIA agrees to provide the Software and any associated materials
 * pursuant to the terms and conditions of this Agreement.  Subject to the
 * terms of this Agreement, NVIDIA grants to You a nonexclusive,
 * transferable, worldwide, revocable, limited, royalty-free, fully paid-up
 * license under NVIDIA’s copyrights to 
 * 
 * (a) install, deploy, use, have used execute, reproduce, display,
 * perform, run, modify the source code of the Software, or to prepare and
 * have prepared Derivative Works thereof the Software for Your own
 * internal development, testing and maintenance purposes to incorporate
 * the Software or Derivative Works thereof, in part or whole, into Your
 * software applications; 
 * 
 * (b)	 to transfer, distribute and sublicense the Software (in its
 * unmodified form as delivered to You by NVIDIA pursuant to this
 * Agreement) in any medium or technology for Your sublicensees to
 * incorporate the Software or Derivative Works thereof, in part or whole,
 * into their respective software applications; and
 * 
 * (c) to transfer, distribute and sublicense Derivative Works (in object
 * code only) of the Software (i)_as incorporated in Your application
 * software in any medium or technology; and (ii) certified as OpenAutomate
 * Compatible Software.
 * 
 * You may exercise your license rights pursuant to Subsection 1(b) and (c)
 * above pursuant to the terms and conditions of any form of end-user
 * software license agreement of Your choice, including but not limited to
 * an Excluded License.
 * 
 * In the event NVIDIA certifies Your application software, incorporating
 * the Derivative Works (in object code only) of the Software, as
 * OpenAutomate compatible ("OpenAutomate Compatible Software"), NVIDIA
 * grants You a nonexclusive, worldwide, revocable, paid-up license to use
 * the name and trademark to "OpenAutomate Compatible" solely for the
 * purposes of identifying and/or marketing Your application software as
 * OpenAutomate Compatible Software; provided that Licensee fully complies
 * with the following:	
 * 
 * (x) Licensee agrees that it is strictly prohibited from using the name
 * and trademark of "OpenAutomate Compatible" if Your application software
 * is not OpenAutomate Compatible Software;
 * 
 * (y) if NVIDIA objects to Your improper use of the "OpenAutomate
 * Compatible" name and trademark, You will take all reasonable steps
 * necessary to resolve NVIDIA’s objections. NVIDIA may reasonably monitor
 * the quality of Your application software bearing the "OpenAutomate
 * Compatible" name or trademark pursuant to this Agreement; and
 * 
 * (z) any goodwill attached to NVIDIA’s trademarks, service marks, or
 * trade names belong to NVIDIA and this Agreement does not grant You any
 * right to use them.
 * 
 * If You are not the final manufacturer or vendor of a computer system or
 * software program incorporating the Software, or if Your Contractors (as
 * defined below), affiliates or subsidiaries need to exercise any, some or
 * all of the license grant described above herein to the Software on Your
 * behalf, then You may transfer a copy of the Software, (and related
 * end-user documentation) to such recipient for use in accordance with the
 * terms of this Agreement, provided such recipient agrees to be fully
 * bound by the terms hereof. Except as expressly permitted in this
 * Agreement, Unless otherwise authorized in the Agreement, You shall not
 * otherwise assign, sublicense, lease, or in any other way transfer or
 * disclose Software to any third party. Unless otherwise authorized in the
 * Agreement, You shall not reverse- compile, disassemble,
 * reverse-engineer, or in any manner attempt to derive the source code of
 * the Software from the object code portions of the Software. 
 * 
 * Except as expressly stated in this Agreement, no license or right is
 * granted to You directly or by implication, inducement, estoppel or
 * otherwise. NVIDIA shall have the right to inspect or have an independent
 * auditor inspect Your relevant records to verify Your compliance with the
 * terms and conditions of this Agreement. 
 * 
 * SECTION 2 - CONFIDENTIALITY.
 * If applicable, any exchange of Confidential Information (as defined in
 * the NDA) shall be made pursuant to the terms and conditions of a
 * separately signed Non-Disclosure Agreement ("NDA") by and between NVIDIA
 * and You. For the sake of clarity, You agree that the Software is
 * Confidential Information of NVIDIA.
 * 
 * If You wish to have a third party consultant or subcontractor
 * ("Contractor") perform work on Your behalf which involves access to or
 * use of Software, You shall obtain a written confidentiality agreement
 * from the Contractor which contains terms and obligations with respect to
 * access to or use of Software no less restrictive than those set forth in
 * this Agreement and excluding any distribution or sublicense rights, and
 * use for any other purpose than permitted in this Agreement. Otherwise,
 * You shall not disclose the terms or existence of this Agreement or use
 * NVIDIA's name in any publications, advertisements, or other
 * announcements without NVIDIA's prior written consent.  Unless otherwise
 * provided in this Agreement, You do not have any rights to use any NVIDIA
 * trademarks or logos.
 * 
 * SECTION 3 - OWNERSHIP OF SOFTWARE AND INTELLECTUAL PROPERTY RIGHTS.
 * All rights, title and interest to all copies of the Software remain with
 * NVIDIA, subsidiaries, licensors, or its suppliers. The Software is
 * copyrighted and protected by the laws of the United States and other
 * countries, and international treaty provisions. You may not remove any
 * copyright notices from the Software. NVIDIA may make changes to the
 * Software, or to items referenced therein, at any time and without
 * notice, but is not obligated to support or update the Software. Except
 * as otherwise expressly provided, NVIDIA grants no express or implied
 * right under any NVIDIA patents, copyrights, trademarks, or other
 * intellectual property rights. 
 * 
 * All rights, title and interest in the Derivative Works of the Software
 * remain with You subject to the underlying license from NVIDIA to the
 * Software.  In Your sole discretion, You may grant NVIDIA, upon NVIDIA’s
 * request for such a license described herein, an irrevocable, perpetual,
 * nonexclusive, worldwide, royalty-free paid-up license to make, have
 * made, use, have used, sell, license, distribute, sublicense or otherwise
 * transfer Derivative Works created by You that add functionality or
 * improvement to the Software.  
 * 
 * You has no obligation to give NVIDIA any suggestions, comments or other
 * feedback ("Feedback") relating to the Software.  However, NVIDIA may use
 * and include any Feedback that You voluntarily provide to improve the
 * Software or other related NVIDIA technologies.  Accordingly, if You
 * provide Feedback, You agree NVIDIA and its licensees may freely use,
 * reproduce, license, distribute, and otherwise commercialize the Feedback
 * in the Software or other related technologies without the payment of any
 * royalties or fees.  
 * 
 * You may transfer the Software only if the recipient agrees to be fully
 * bound by these terms and conditions of this Agreement. 
 * 
 * SECTION 4 - NO WARRANTIES. 
 * THE SOFTWARE IS PROVIDED "AS IS" WITHOUT ANY EXPRESS OR IMPLIED WARRANTY
 * OF ANY KIND, INCLUDING WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT,
 * OR FITNESS FOR A PARTICULAR PURPOSE. NVIDIA does not warrant or assume
 * responsibility for the accuracy or completeness of any information,
 * text, graphics, links or other items contained within the Software.
 * NVIDIA does not represent that errors or other defects will be
 * identified or corrected.
 * 
 * SECTION 5 - LIMITATION OF LIABILITY.
 * EXCEPT WITH RESPECT TO THE MISUSE OF THE OTHER PARTY’S INTELLECTUAL
 * PROPERTY OR DISCLOSURE OF THE OTHER PARTY’S CONFIDENTIAL INFORMATION IN
 * BREACH OF THIS AGREEMENT, IN NO EVENT SHALL NVIDIA, SUBSIDIARIES,
 * LICENSORS, OR ITS SUPPLIERS BE LIABLE FOR ANY DAMAGES WHATSOEVER
 * (INCLUDING, WITHOUT LIMITATION,  INDIRECT, LOST PROFITS, CONSEQUENTIAL,
 * BUSINESS INTERRUPTION OR LOST INFORMATION) ARISING OUT OF THE USE OF OR
 * INABILITY TO USE THE SOFTWARE, EVEN IF NVIDIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGES. SOME JURISDICTIONS PROHIBIT EXCLUSION OR
 * LIMITATION OF LIABILITY FOR IMPLIED WARRANTIES OR CONSEQUENTIAL OR
 * INCIDENTAL DAMAGES, SO THE ABOVE LIMITATION MAY NOT APPLY TO YOU. YOU
 * MAY ALSO HAVE OTHER LEGAL RIGHTS THAT VARY FROM JURISDICTION TO
 * JURISDICTION.  NOTWITHSTANDING THE FOREGOING, NVIDIA’S AGGREGATE
 * LIABILITY ARISING OUT OF THIS AGREEMENT SHALL NOT EXCEED ONE HUNDRED
 * UNITED STATES DOLLARS (USD$100).
 * 
 * SECTION 6 - TERM.
 * This Agreement and the licenses granted hereunder shall be effective as
 * of the date You download the applicable Software ("Effective Date") and
 * continue for a period of one (1) year ("Initial Term") respectively,
 * unless terminated earlier in accordance with the "Termination" provision
 * of this Agreement.  Unless either party notifies the other party of its
 * intent to terminate this Agreement at least three (3) months prior to
 * the end of the Initial Term or the applicable renewal period, this
 * Agreement will be automatically renewed for one (1) year renewal periods
 * thereafter, unless terminated in accordance with the "Termination"
 * provision of this Agreement.  
 * 
 * SECTION 7 - TERMINATION.
 * NVIDIA may terminate this Agreement at any time if You violate its
 * terms. Upon termination, You will immediately destroy the Software or
 * return all copies of the Software to NVIDIA, and certify to NVIDIA in
 * writing that such actions have been completed.  Upon termination or
 * expiration of this Agreement the license grants to Licensee shall
 * terminate, except that sublicenses rightfully granted by Licensee under
 * this Agreement in connection with Section 1(b) and (c) of this Agreement
 * provided by Licensee prior to the termination or expiration of this
 * Agreement shall survive in accordance with their respective form of
 * license terms and conditions.
 * 
 * SECTION 8 - MISCELLANEOUS.
 * 
 * SECTION 8.1 - SURVIVAL.
 * Those provisions in this Agreement, which by their nature need to
 * survive the termination or expiration of this Agreement, shall survive
 * termination or expiration of the Agreement, including but not limited to
 * Sections 2, 3, 4, 5, 7, and 8.
 * 
 * SECTION 8.2 - APPLICABLE LAWS.
 * Claims arising under this Agreement shall be governed by the laws of
 * Delaware, excluding its principles of conflict of laws and the United
 * Nations Convention on Contracts for the Sale of Goods. The state and/or
 * federal courts residing in Santa Clara County, California shall have
 * exclusive jurisdiction over any dispute or claim arising out of this
 * Agreement. You may not export the Software in violation of applicable
 * export laws and regulations. 
 * 
 * SECTION 8.3 - AMENDMENT.
 * The Agreement shall not be modified except by a written agreement that
 * names this Agreement and any provision to be modified, is dated
 * subsequent to the Effective Date, and is signed by duly authorized
 * representatives of both parties.
 * 
 * SECTION 8.4 - NO WAIVER.
 * No failure or delay on the part of either party in the exercise of any
 * right, power or remedy under this Agreement or under law, or to insist
 * upon or enforce performance by the other party of any of the provisions
 * of this Agreement or under law, shall operate as a waiver thereof, nor
 * shall any single or partial exercise of any right, power or remedy
 * preclude other or further exercise thereof, or the exercise of any other
 * right, power or remedy; rather the provision, right, or remedy shall be
 * and remain in full force and effect.
 * 
 * SECTION 8.5 - NO ASSIGNMENT. 
 * This Agreement and Licensee’s rights and obligations herein, may not be
 * assigned, subcontracted, delegated, or otherwise transferred by Licensee
 * without NVIDIA’s prior written consent, and any attempted assignment,
 * subcontract, delegation, or transfer in violation of the foregoing will
 * be null and void.  The terms of this Agreement shall be binding upon
 * Licensee’s assignees.
 * 
 * SECTION 8.6 - GOVERNMENT RESTRICTED RIGHTS. 
 * The parties acknowledge that the Software is subject to U.S. export
 * control laws and regulations.   The parties agree to comply with all
 * applicable international and national laws that apply to the Software,
 * including the U.S. Export Administration Regulations, as well as
 * end-user, end-use and destination restrictions issued by U.S. and other
 * governments.
 * 
 * The Software has been developed entirely at private expense and is
 * commercial computer software provided with RESTRICTED RIGHTS. Use,
 * duplication or disclosure of the Software by the U.S. Government or a
 * U.S. Government subcontractor is subject to the restrictions set forth
 * in the Agreement under which the Software was obtained pursuant to DFARS
 * 227.7202-3(a) or as set forth in subparagraphs (c)(1) and (2) of the
 * Commercial Computer Software - Restricted Rights clause at FAR
 * 52.227-19, as applicable. Contractor/manufacturer is NVIDIA, 2701 San
 * Tomas Expressway, Santa Clara, CA 95050. Use of the Software by the
 * Government constitutes acknowledgment of NVIDIA's proprietary rights
 * therein. 
 * 
 * SECTION 8.7 - INDEPENDENT CONTRACTORS.
 * Licensee’s relationship to NVIDIA is that of an independent contractor,
 * and neither party is an agent or partner of the other.  Licensee will
 * not have, and will not represent to any third party that it has, any
 * authority to act on behalf of NVIDIA.
 * 
 * SECTION 8.8 - SEVERABILITY.
 * If for any reason a court of competent jurisdiction finds any provision
 * of this Agreement, or portion thereof, to be unenforceable, that
 * provision of the Agreement will be enforced to the maximum extent
 * permissible so as to affect the intent of the parties, and the remainder
 * of this Agreement will continue in full force and effect. This Agreement
 * has been negotiated by the parties and their respective counsel and will
 * be interpreted fairly in accordance with its terms and without any
 * strict construction in favor of or against either party.
 * 
 * SECTION 8.9 - ENTIRE AGREEMENT.  
 * This Agreement and NDA constitute the entire agreement between the
 * parties with respect to the subject matter contemplated herein, and
 * merges all prior and contemporaneous communications.
 * 
 ******************************************************************************/



#include <iostream>
#include <string.h>
#include <stdlib.h>

#include <oaRPC.h>
#include <oaRPCSocketTransport.h>
#include <OpenAutomate_Internal.h>
#include "test.h"

#define PRINT(var) \
  std::cerr << __FILE__ << ", " << __LINE__ << ": " #var " = " << (var) \
            << std::endl;

#define MSG(msg) \
  std::cerr << __FILE__ << ", " << __LINE__ << ": " << (msg) \
            << std::endl;

#define OABOOL(bool_val) (((int)(bool_val) == 0) ? OA_FALSE : OA_TRUE)

using namespace std;

/*******************************************************************************
 *** Globals
 ******************************************************************************/

static int Port = 6969;
static const char *ExeCmd;
static void *ClientProcess = NULL;

static oaNamedOption RefOptions[128];
static oaInt NumRefOptions = 0;

static oaRPCServer *Server = NULL;

static struct
       {
         const char *Name;
         oaOptionDataType Type;
         oaValue Value;
       } RefOptionValues[128];
static oaInt NumRefOptionValues = 0;

const oaChar *Benchmarks[] = {
                               "forest",
                               "crates",
                               "map1",
                               NULL
                             };
oaInt NumBenchmarks = -1;

oaChar LogMsg[] = "This is a log message.";
                        

oaInt Counter_GetNextCommand = 0;
oaInt Counter_GetNextOption = 0;
oaInt Counter_AddOption = 0;
oaInt Counter_AddOptionValue = 0;
oaInt Counter_AddBenchmark = 0;
oaInt Counter_SendSignal = 0;
oaInt Counter_DisplayFrame = 0;
oaInt Counter_AddResultValue = 0;
oaInt Counter_AddFrameValue = 0;

/*******************************************************************************
 *** Prototypes
 ******************************************************************************/

static oaBool StringsAreEqual(const char *s1, const char *s2);
static oaBool ValuesAreEqual(oaOptionDataType type, oaValue v1, oaValue v2);
static oaBool OptsAreEqual(const oaNamedOption *opt1, 
                           const oaNamedOption *opt2);
static void Exit(int exit_code);


/*******************************************************************************
 *** Client Functions
 ******************************************************************************/

const oaiFunctionTable *FuncTable = NULL;

void LaunchClient(void)
{
  char Cmd[4096] = "\"";

  strncat(Cmd, ExeCmd, sizeof(Cmd));
  strncat(Cmd, "\" -client", sizeof(Cmd));

  ClientProcess = test_RunCmdAsync(Cmd);
  assert(ClientProcess != NULL);
  if(ClientProcess == NULL)
    Exit(4);

  MSG("Client launched successfully");
}

  
static void ClientGetAllOptions(void)
{
  oaInt i;
  assert(FuncTable->AddOption);

  for(i=0; i < NumRefOptions; ++i)
    FuncTable->AddOption(&RefOptions[i]);
}

static void GetCurrentOptions(void)
{
  oaInt i;
  assert(FuncTable->AddOptionValue);

  for(i=0; i < NumRefOptionValues; ++i)
    FuncTable->AddOptionValue(RefOptionValues[i].Name,
                              RefOptionValues[i].Type,
                              &RefOptionValues[i].Value);
}

static void SetOptions(void)
{
  oaInt i;
  oaNamedOption *Option;
  assert(FuncTable->GetNextOption);

  for(i=0; (Option = FuncTable->GetNextOption()) != NULL; ++i)
  {
    TEST(StringsAreEqual(Option->Name, RefOptionValues[i].Name) == OA_TRUE)
    TEST(Option->DataType == RefOptionValues[i].Type)
    TEST(ValuesAreEqual(Option->DataType, 
                        Option->Value, 
                        RefOptionValues[i].Value) == OA_TRUE)
  }

  TEST(i == NumRefOptionValues)
}

static void GetBenchmarks(void)
{
  oaInt i=0;
  assert(FuncTable->AddBenchmark);

  for(i=0; i < NumBenchmarks; ++i)
    FuncTable->AddBenchmark(Benchmarks[i]);
}

static void RunBenchmark(const char *benchmark_name)
{
  int i;
  oaMessage Message;
  oaValue Val;

  assert(FuncTable->SendSignal != NULL);
  assert(FuncTable->StartBenchmark != NULL);
  assert(FuncTable->EndBenchmark != NULL);
  assert(FuncTable->DisplayFrame != NULL);
  assert(FuncTable->AddResultValue != NULL);
  assert(FuncTable->AddFrameValue != NULL);

  FuncTable->StartBenchmark();

  /* Test SendSignal() */
  TEST(FuncTable->SendSignal(OA_SIGNAL_SYSTEM_REBOOT, NULL) == TRUE)

  Message.Error = OA_ERROR_LOG;
  Message.Message = LogMsg;
  TEST(FuncTable->SendSignal(OA_SIGNAL_ERROR, &Message) == TRUE)

  TEST(StringsAreEqual(benchmark_name, Benchmarks[0]) == OA_TRUE)

  for(i=0; i < 10; ++i)
  {
    FuncTable->DisplayFrame((oaFloat)i);
    Val.Int = i;
    FuncTable->AddFrameValue("frame number", OA_TYPE_INT, &Val);
  }

  Val.Int = 18249;
  FuncTable->AddResultValue("Score", OA_TYPE_INT, &Val);

  Val.Float = 29.14;
  FuncTable->AddResultValue("Some other score", OA_TYPE_FLOAT, &Val);

  FuncTable->EndBenchmark();
}

void ClientMain(void)
{
  oaRPCTransport Transport;
  char Hostname[] = "localhost";
  
  oaRPCTransportErrorType tsRet;


  tsRet = oaRPCInitSocketClientTransport(&Transport, 
                                       Hostname, 
                                       Port);

  TEST(tsRet == OARPC_TRANSPORT_ERROR_OK)
  if(tsRet != OARPC_TRANSPORT_ERROR_OK)
    Exit(1);

  MSG("Client: established connection to server");

  oaVersion Version;
  OA_INIT_VERSION_STRUCT(Version);

  FuncTable = oaRPCInitClient(&Transport, &Version);
  TEST(FuncTable != NULL);
  if(!FuncTable)
    Exit(2);

  TEST(FuncTable->GetNextCommand != NULL)

  {
    oaCommand Command;

    while(1)
    {
      switch(FuncTable->GetNextCommand(&Command))
      {
        /* No more commands, exit program */
        case OA_CMD_EXIT: 
          return;

        case OA_CMD_GET_ALL_OPTIONS:
          ClientGetAllOptions();
          break;

        case OA_CMD_GET_CURRENT_OPTIONS:
          GetCurrentOptions();
          break;

        case OA_CMD_SET_OPTIONS:
          SetOptions();
          break;

        case OA_CMD_GET_BENCHMARKS:
          GetBenchmarks();
          break;

        case OA_CMD_RUN_BENCHMARK:
          RunBenchmark(Command.BenchmarkName);
          break;
      }
    }
  }
}

/*******************************************************************************
 *** Server Functions
 ******************************************************************************/

static oaRPCTransport Transport;

static oaBool StartServer(void)
{
  oaRPCTransportErrorType Ret;

  Ret = oaRPCInitSocketServerTransport(&Transport, Port);
  TEST(Ret == OARPC_TRANSPORT_ERROR_OK);

  return(Ret == OARPC_TRANSPORT_ERROR_OK ? OA_TRUE : OA_FALSE);
}


static oaCommandType GetNextCommand(void* context, oaCommand *command)
{
  static int CurrentStage = 0;
  Counter_GetNextCommand++;

  switch(CurrentStage)
  {
    case 0:
      CurrentStage++;
      return(OA_CMD_GET_ALL_OPTIONS);

    case 1:
       {
        oaCommand Command;
        oaInitCommand(&Command);
        Command.Type = OA_CMD_GET_CURRENT_OPTIONS;
        CurrentStage++;
        oaRPCServerNestCommand(Server, &Command);
       }

      CurrentStage++;
      return(OA_CMD_SET_OPTIONS);

    case 2:
      // Should never be here because of nested command in stage 1
      assert("Should not be here!" == NULL);
      break;

    case 3:
      CurrentStage++;
      return(OA_CMD_GET_BENCHMARKS);

    case 4:
      CurrentStage++;
      command->BenchmarkName = (oaString)Benchmarks[0];
      return(OA_CMD_RUN_BENCHMARK);

    case 5:
      CurrentStage++;
      return(OA_CMD_EXIT);
  }

  return(OA_CMD_EXIT);
}

static oaNamedOption *GetNextOption(void* context)
{
  static oaInt OptCount = 0;
  static oaNamedOption Option;

  Counter_GetNextOption++;

  memset(&Option, 0, sizeof(Option));

  if(OptCount == NumRefOptionValues)
    return(NULL);

  Option.DataType = RefOptionValues[OptCount].Type;
  Option.Name = (oaString)RefOptionValues[OptCount].Name;
  Option.Value = RefOptionValues[OptCount].Value;
  OptCount++;

  return(&Option);
}

static void AddOption(void* context, const oaNamedOption *option)
{
  static oaInt OptCount = 0;

  Counter_AddOption++;

  TEST(OptsAreEqual(option, &RefOptions[OptCount++]) == OA_TRUE);
}

static void AddOptionValue(void *context,
                           const oaChar *name, 
                           oaOptionDataType value_type,
                           const oaValue *value)
{
  static oaInt OptCount = 0;

  Counter_AddOptionValue++;

  TEST(StringsAreEqual(name, RefOptionValues[OptCount].Name) == OA_TRUE);
  TEST(value_type == RefOptionValues[OptCount].Type);
  TEST(ValuesAreEqual(value_type, *value, RefOptionValues[OptCount].Value) == 
       OA_TRUE);
  OptCount++;
}

static void AddBenchmark(void *context, const oaChar *benchmark_name)
{
  const oaChar *Benchmark = Benchmarks[Counter_AddBenchmark];

  Counter_AddBenchmark++;

  TEST(StringsAreEqual(benchmark_name, Benchmark) == OA_TRUE);
}

static oaBool SendSignal(void *context, oaSignalType signal, void *param)
{
  switch(Counter_SendSignal)
  {
    case 0:
      TEST(signal == OA_SIGNAL_SYSTEM_REBOOT);
      TEST(param == NULL);
      break;

    case 1:
      {
        oaMessage *Message = (oaMessage *)param;
        TEST(signal == OA_SIGNAL_ERROR);
        TEST(Message != NULL);
        TEST(Message->Error == OA_ERROR_LOG);
        TEST(StringsAreEqual(Message->Message, LogMsg) == OA_TRUE)
      }
      break;

    default:
      TEST("Shouldn't be here" == NULL);
  }

  Counter_SendSignal++;

  return(OA_TRUE);
}

static void StartBenchmark(void *context)
{
  TEST(OA_TRUE); // Add a test to the count to insure this was called once
}

static void EndBenchmark(void *context)
{
  TEST(OA_TRUE); // Add a test to the count to insure this was called once
}

static void DisplayFrame(void *context, oaFloat t)
{
  static oaFloat CurT = 0.0;

  TEST(t == CurT);
  CurT++;
  Counter_DisplayFrame++;
}

static void AddResultValue(void *context,
                           const oaChar *name, 
                           oaOptionDataType value_type,
                           const oaValue *value)
{
  static oaInt Count = 0;

  switch(Count)
  {
    case 0:
      TEST(StringsAreEqual(name, "Score") == OA_TRUE)
      TEST(value_type == OA_TYPE_INT)
      TEST(value->Int == 18249)
      break;

    case 1:
      TEST(StringsAreEqual(name, "Some other score") == OA_TRUE)
      TEST(value_type == OA_TYPE_FLOAT)
      TEST(value->Float == 29.14)
      break;

    default:
      TEST("Shouldn't be here" == NULL)
  }

  Counter_AddResultValue++;
  Count++;
}

static void AddFrameValue(void *context,
                          const oaChar *name, 
                          oaOptionDataType value_type,
                          const oaValue *value)
{
  static oaInt Count = 0;

  TEST(StringsAreEqual(name, "frame number") == OA_TRUE)
  TEST(value_type == OA_TYPE_INT)
  TEST(value->Int == Count)

  Counter_AddFrameValue++;
  Count++;
}

/*******************************************************************************
 *** Test main
 ******************************************************************************/

static void Init(void);

TEST_INIT_PLANNED(100)

  oaRPCServerErrorType Ret;
  oaBool NoLaunchClient = OA_FALSE;
  oaRPCFunctionTable ServerFuncTable;

  Init();

  memset(&ServerFuncTable, 0, sizeof(ServerFuncTable));
  ServerFuncTable.TableSize = sizeof(ServerFuncTable);
  ServerFuncTable.GetNextCommand = GetNextCommand;
  ServerFuncTable.GetNextOption = GetNextOption;
  ServerFuncTable.AddOption = AddOption;
  ServerFuncTable.AddOptionValue = AddOptionValue;
  ServerFuncTable.AddBenchmark = AddBenchmark;
  ServerFuncTable.SendSignal = SendSignal;
  ServerFuncTable.StartBenchmark = StartBenchmark;
  ServerFuncTable.EndBenchmark = EndBenchmark;
  ServerFuncTable.DisplayFrame = DisplayFrame;
  ServerFuncTable.AddResultValue = AddResultValue;
  ServerFuncTable.AddFrameValue = AddFrameValue;

  ExeCmd = argv[0];

  if(argc > 1 && !strcmp(argv[1], "-client"))
  {
    ClientMain();
    
    oaRPCCleanup();

    if(test_NTestsRan - test_NTestsSucceeded > 0)
      Exit(-1);

    return(0);
  }

  if(argc > 1 && !strcmp(argv[1], "-nolaunch"))
    NoLaunchClient = OA_TRUE;
  

  if(StartServer() == OA_TRUE)
  {
    int ExitCode;

    if(!NoLaunchClient)
      LaunchClient();

    Server = oaRPCCreateServer(&ServerFuncTable, 
                               &Transport, 
                               NULL);

    Ret = oaRPCRunServer(Server, OARPC_INFINITE);
    TEST(Ret == OARPC_SERVER_ERROR_OK);

    TEST(oaRPCDestroyServer(Server) == TRUE);

    TEST(Counter_GetNextCommand == 5);
    TEST(Counter_GetNextOption == NumRefOptionValues + 1);
    TEST(Counter_AddOption == NumRefOptions)  ;
    TEST(Counter_AddOptionValue == NumRefOptionValues);
    TEST(NumBenchmarks > 0);
    TEST(Counter_AddBenchmark == NumBenchmarks);
    TEST(Counter_SendSignal == 2);
    TEST(Counter_DisplayFrame == 10);
    TEST(Counter_AddResultValue == 2);
    TEST(Counter_AddFrameValue == 10);

    if(!NoLaunchClient)
    {
      TEST(test_WaitProcess(ClientProcess, &ExitCode) != 0);
      TEST(ExitCode == 0);
    }

    oaRPCCleanupTransport(&Transport);
    oaRPCCleanup();
  }

TEST_END


/*******************************************************************************
 *** Functions
 ******************************************************************************/

static void Init(void)
{
  //****************************************************************************
  //*** Init RefOptions
  //****************************************************************************
  {
    oaNamedOption *Option;
    

    Option = &RefOptions[NumRefOptions++];
    oaInitOption(Option);
    Option->Name = "Resolution";
    Option->DataType = OA_TYPE_ENUM;
    Option->Value.Enum = "640x480";

    RefOptions[NumRefOptions] = *Option;
    Option = &RefOptions[NumRefOptions++];
    Option->Value.Enum = "1024x768";

    RefOptions[NumRefOptions] = *Option;
    Option = &RefOptions[NumRefOptions++];
    Option->Value.Enum = "1600x1200";

    /* AA (enum) */
    Option = &RefOptions[NumRefOptions++];
    oaInitOption(Option);
    Option->Name = "AA";
    Option->DataType = OA_TYPE_ENUM;

    Option->Value.Enum = "Off";

    RefOptions[NumRefOptions] = *Option;
    Option = &RefOptions[NumRefOptions++];
    Option->Value.Enum = "2X";

    RefOptions[NumRefOptions] = *Option;
    Option = &RefOptions[NumRefOptions++];
    Option->Value.Enum = "4X";

    /* Sound (bool) */
    Option = &RefOptions[NumRefOptions++];
    oaInitOption(Option);
    Option->Name = "Resolution";
    Option->DataType = OA_TYPE_BOOL;

    /* Music Enabled (bool) */
    Option = &RefOptions[NumRefOptions++];
    oaInitOption(Option);
    Option->Name = "Music Enabled";
    Option->DataType = OA_TYPE_BOOL;
    Option->Dependency.ParentName = "Sound";
    Option->Dependency.ComparisonOp = OA_COMP_OP_EQUAL;
    Option->Dependency.ComparisonVal.Bool = OA_ON;

    /* Enemy Density (int) */
    Option = &RefOptions[NumRefOptions++];
    oaInitOption(Option);
    Option->Name = "Enemy Density";
    Option->DataType = OA_TYPE_INT;
    Option->MinValue.Int = 0;
    Option->MaxValue.Int = 100;
    Option->NumSteps = 1;

    /* Texture Quality (float) */
    Option = &RefOptions[NumRefOptions++];
    oaInitOption(Option);
    Option->Name = "Texture Quality";
    Option->DataType = OA_TYPE_FLOAT;
    Option->MinValue.Float = 0.0;
    Option->MaxValue.Float = 100.0;
    Option->NumSteps = 201;
  }

  //****************************************************************************
  //*** Init RefOptionValues
  //****************************************************************************


#define ADD_REF_OPTION_VALUE_STRING(name, val) \
   RefOptionValues[NumRefOptionValues].Name = name; \
   RefOptionValues[NumRefOptionValues].Type = OA_TYPE_STRING;  \
   RefOptionValues[NumRefOptionValues++].Value.String = val; 

#define ADD_REF_OPTION_VALUE_ENUM(name, val) \
   RefOptionValues[NumRefOptionValues].Name = name; \
   RefOptionValues[NumRefOptionValues].Type = OA_TYPE_ENUM;  \
   RefOptionValues[NumRefOptionValues++].Value.Enum = val; 

#define ADD_REF_OPTION_VALUE_INT(name, val) \
   RefOptionValues[NumRefOptionValues].Name = name; \
   RefOptionValues[NumRefOptionValues].Type = OA_TYPE_INT;  \
   RefOptionValues[NumRefOptionValues++].Value.Int = val; 

#define ADD_REF_OPTION_VALUE_FLOAT(name, val) \
   RefOptionValues[NumRefOptionValues].Name = name; \
   RefOptionValues[NumRefOptionValues].Type = OA_TYPE_FLOAT;  \
   RefOptionValues[NumRefOptionValues++].Value.Float = val; 

#define ADD_REF_OPTION_VALUE_BOOL(name, val) \
   RefOptionValues[NumRefOptionValues].Name = name; \
   RefOptionValues[NumRefOptionValues].Type = OA_TYPE_BOOL;  \
   RefOptionValues[NumRefOptionValues++].Value.Bool = val; 

  {
    ADD_REF_OPTION_VALUE_STRING("Resolution", "1024x768")
    ADD_REF_OPTION_VALUE_ENUM("AA", "4X")
    ADD_REF_OPTION_VALUE_BOOL("Sound", OA_OFF)
    ADD_REF_OPTION_VALUE_INT("Compression Level", 5)
    ADD_REF_OPTION_VALUE_INT("Enemy Density", 70)
    ADD_REF_OPTION_VALUE_FLOAT("Texture Quality", 20.5)
  }

  //****************************************************************************
  //*** Init Benchmarks
  //****************************************************************************

  for(NumBenchmarks=0; Benchmarks[NumBenchmarks]; ++NumBenchmarks);

}


static oaBool StringsAreEqual(const char *s1, const char *s2)
{
  if(s1 == NULL && s2 == NULL)
    return(OA_TRUE);

  if(s1 == NULL || s2 == NULL)
    return(OA_FALSE);

  return(OABOOL(strcmp(s1, s2) == 0));
}

static oaBool ValuesAreEqual(oaOptionDataType type, oaValue v1, oaValue v2)
{
  switch(type)
  {
    case OA_TYPE_STRING:
      return(StringsAreEqual(v1.String, v2.String));

    case OA_TYPE_ENUM:
      return(StringsAreEqual(v1.Enum, v2.Enum));

    case OA_TYPE_INT:
      return(OABOOL(v1.Int == v2.Int));

    case OA_TYPE_FLOAT:
      return(OABOOL(v1.Float == v2.Float));

    case OA_TYPE_BOOL:
      return(OABOOL(v1.Bool == v2.Bool));

    default:
      assert("Unkown type!" == NULL);
  }

  return(OA_FALSE);
}

static oaBool OptsAreEqual(const oaNamedOption *opt1, 
                           const oaNamedOption *opt2)
{
  assert(opt1 != NULL);
  assert(opt2 != NULL);

  if(opt1->DataType != opt2->DataType)
    return(OA_FALSE);

  if(!StringsAreEqual(opt1->Name, opt2->Name))
    return(OA_FALSE);

  if(!ValuesAreEqual(opt1->DataType, opt1->Value, opt2->Value))
    return(OA_FALSE);

  if(!ValuesAreEqual(opt1->DataType, opt1->MinValue, opt2->MinValue))
    return(OA_FALSE);

  if(!ValuesAreEqual(opt1->DataType, opt1->MaxValue, opt2->MaxValue))
    return(OA_FALSE);

  if(opt1->NumSteps != opt2->NumSteps)
    return(OA_FALSE);

  if(opt1->NumSteps != opt2->NumSteps)
    return(OA_FALSE);

  if(!StringsAreEqual(opt1->Dependency.ParentName, opt2->Dependency.ParentName))
    return(OA_FALSE);

  if(opt1->Dependency.ComparisonOp != opt2->Dependency.ComparisonOp)
    return(OA_FALSE);

  /* todo:rev:need state to know type of parent op for comparison of  
     Dependency.ComparisonVal */

  return(OA_TRUE);
}

static void Exit(int exit_code)
{
  exit(exit_code);
}
